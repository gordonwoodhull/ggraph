{"version":3,"sources":["src/banner.js","src/core.js","src/graph.js","src/pattern.js","src/footer.js","src/dataflow.js","src/dataflow_calcs.js","src/interface.js","src/graph_pattern.js","src/subgraph_pattern.js","src/topological_sort.js","src/compose.js"],"names":["_metagraph","metagraph","version","mg","as_array","a","Array","isArray","as_keyvalue","o","Object","keys","map","key","value","build_map","vals","keyf","wrap","reduce","val","graph_options","opts","assign","nodeKey","kv","edgeKey","nodeValue","edgeValue","edgeSource","source","edgeTarget","target","define_dataflow","flowspec","defn","flownodes","nodes","fsn","calc","node","dataflow","edges","e","graph","_nodeMap","_edgeMap","_nodesList","_edgesList","_outsList","_insList","options","build_node_map","node_wrapper","build_edge_map","edge_wrapper","build_directional_edge_lists","acc","v","push","_graph","edge","n","outs","ins","graph_adjacency","graph_incidence","gropts","nodeIncidences","incidencesOutward","incidence_options","forEach","nk","outward","ik","edge_key","edge_value","graph_detect","spec","incidences","Error","flowgraph","instantiate","instance","inputs","_inst","_yes_i_am_really_dataflow","id","apply","console","assert","input","namespace","field","pattern","flowspecs","interf","interface","inode","members","class_members","iedge","ekey","evalue","fs","split","action","member","funfun","deps","flow","dep","parts","length","arguments","resolve","name","nkey","cmemspec","memspec","mem","accessor","wrapper","inodes2","n2","iedges2","path","fnode","output","x","iref","refs","data","bind","singleton","list","map_of_lists","subset","items","set","Set","filter","r","has","createable","flowkey","create","flowg","env","call","methodname","f","reference","fetch","lookupArg","access","lookupFVal","lookupKVal","subgraph","subflow","graflow","dest","nodeKeys","edgeKeys","gdata","sgflow","parent","genv","gflow","graph_pattern","node_by_key","edge_by_key","node_list","edge_list","node_outs","node_ins","Graph","Node","Edge","graph_node","node_graph","graph_nodes","graph_edge","edge_graph","graph_edges","edge_source","edge_target","subgraph_pattern","parent_nodes","parent_edges","node_keys","edge_keys","subset_nodes","subset_edges","ParentGraph","ChildGraph","subnode","subedge","subgraphS","subnodeS","subedgeS","topological_sort","stacked","marked","sorted","visit","unshift","i","compose","composition","built","input_edge","patnode","find","pe","fnodes","fn","v2","ref","fedges","mappings","lookup","key2","val2","define","amd","module","exports","this"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;CAAA,WAAc,SAASA,IACvB,aCDA,IAAIC,GACAC,QAAS,SAETC,EAAKF,EAET,SAASG,EAASC,GACd,OAAQA,QAAYC,MAAMC,QAAQF,GAAKA,GAAKA,IAGhD,SAASG,EAAYC,GACjB,OAAQA,QAAYH,MAAMC,QAAQE,GAAKA,EAAIC,OAAOC,KAAKF,GAAGG,IAAI,SAASC,GACnE,OAAQA,IAAKA,EAAKC,MAAOL,EAAEI,OAInC,SAASE,EAAUC,EAAMC,EAAMC,GAC3B,OAAOF,EAAKG,OAAO,SAASV,EAAGW,GAE3B,OADAX,EAAEQ,EAAKG,IAAQF,EAAKE,GACbX,OClBf,SAASY,EAAcC,GACnB,OAAOZ,OAAOa,QACVC,QAAS,SAASC,GAAM,OAAOA,EAAGZ,KAClCa,QAAS,SAASD,GAAM,OAAOA,EAAGZ,KAClCc,UAAW,SAASF,GAAM,OAAOA,EAAGX,OACpCc,UAAW,SAASH,GAAM,OAAOA,EAAGX,OACpCe,WAAY,SAASJ,GAAM,OAAOA,EAAGX,MAAMgB,QAC3CC,WAAY,SAASN,GAAM,OAAOA,EAAGX,MAAMkB,SAC5CV,OCmFP,SAASW,EAAgBC,EAAUC,GAC/B,IAAIC,EAAYF,EAASG,QAAQzB,IAAI,SAAS0B,GAC1C,OACIzB,IAAKyB,EAAIzB,MACTC,OACIyB,KAAMD,EAAIxB,QAAQ0B,KAAKD,KAAKD,EAAtBA,CAA2BH,OAI7C,OAAOhC,EAAGsC,UACNJ,MAAOD,EACPM,MAAOR,EAASQ,QAAQ9B,IAAI+B,KAAO9B,IAAK8B,EAAE9B,MAAOC,MAAO6B,EAAE7B,aCtGlE,OFUAb,EAAU2C,MAAQ,SAASP,EAAOK,EAAOpB,GACrCe,EAAQ7B,EAAY6B,GACpBK,EAAQlC,EAAYkC,GACpB,IAEIG,EAAUC,EAAUC,EAAYC,EAAYC,EAAWC,EAFvDC,EAAU9B,EAAcC,GAI5B,SAAS8B,IACFP,IAEHA,EAAW9B,EAAUsB,EAAOc,EAAQ3B,QAAS6B,IAEjD,SAASC,IACFR,IAEHA,EAAW/B,EAAU2B,EAAOS,EAAQzB,QAAS6B,IAcjD,SAASC,EAA6BC,GAElC,OADAH,IACOZ,EAAMvB,OAAO,SAASV,EAAGiD,GAG5B,OAFQjD,EAAEgD,EAAIC,IAAMjD,EAAEgD,EAAIC,SACxBC,KAAKC,EAAOC,KAAKV,EAAQzB,QAAQgC,KAC5BjD,OAaf,SAAS4C,EAAaS,GAClB,OACIhD,MAAO,WACH,OAAOqC,EAAQxB,UAAUmC,IAE7BjD,IAAK,WACD,OAAOsC,EAAQ3B,QAAQsC,IAE3BlB,MAAO,WACH,OAAOgB,GAEXG,KAAM,WAEF,OAtBLd,IAEHA,EAAYO,EAA6BL,EAAQtB,aAoBlCoB,EAAUE,EAAQ3B,QAAQsC,SAErCE,IAAK,WAED,OArBLd,IAEHA,EAAWM,EAA6BL,EAAQpB,aAmBjCmB,EAASC,EAAQ3B,QAAQsC,UAI5C,SAASP,EAAaZ,GAClB,OACI7B,MAAO,WACH,OAAOqC,EAAQvB,UAAUe,IAE7B9B,IAAK,WACD,OAAOsC,EAAQzB,QAAQiB,IAE3BC,MAAO,WACH,OAAOgB,GAEX9B,OAAQ,WACJ,OAAO8B,EAAOpB,KAAKW,EAAQtB,WAAWc,KAE1CX,OAAQ,WACJ,OAAO4B,EAAOpB,KAAKW,EAAQpB,WAAWY,MAIlD,IAAIiB,GACApB,KAAM,SAAS3B,GAEX,OADAuC,IACOP,EAAShC,IAEpBgD,KAAM,SAAShD,GAEX,OADAyC,IACOR,EAASjC,IAEpBwB,MAAO,WAEH,OAhFDU,IAEHK,IACAL,EAAaV,EAAMzB,IAAI,SAAS8C,GAAK,OAAOE,EAAOpB,KAAKW,EAAQ3B,QAAQkC,OA6E7DX,GAEXL,MAAO,WAEH,OA9EDM,IAEHM,IACAN,EAAaN,EAAM9B,IAAI,SAAS8C,GAAK,OAAOE,EAAOC,KAAKV,EAAQzB,QAAQgC,OA2E7DV,IAGf,OAAOY,GAGX3D,EAAUgE,gBAAkBhE,EAAU2C,MAWtC3C,EAAUiE,gBAAkB,SAAS7B,EAAOf,GACxCe,EAAQ7B,EAAY6B,GACpB,IAAIc,EAZR,SAA2B7B,GACvB,IAAI6C,EAAS9C,EAAcC,GAC3B,OAAOZ,OAAOa,QACV6C,eAAgBN,GAAKA,IAAMA,EAAEpB,OAASoB,EAAEE,KAAOF,EAAEC,UACjDM,kBAAmBP,IACf,IAAIJ,EAAIS,EAAOxC,UAAUmC,GACzB,OAAQJ,MAA6BA,EAAEhB,QAASgB,EAAEK,QAEvDI,GAIWG,CAAkBhD,GAC5BoB,KAwBJ,OAXAL,EAAMkC,QAAQ,SAAST,GACnB,IAAIU,EAAKrB,EAAQ3B,QAAQsC,GACrBW,EAAUtB,EAAQkB,kBAAkBP,GACxC1D,EAAS+C,EAAQiB,eAAejB,EAAQxB,UAAUmC,KAC7CS,QAAQ,SAASG,GACdhC,EAAMiB,MACF9C,IAThB,SAAkB4D,EAASD,EAAIE,GAC3B,OAAOD,EAAUD,EAAK,IAAME,EAAKA,EAAK,IAAMF,EAQ3BG,CAASF,EAASD,EAAIE,GAC3B5D,MAnBhB,SAAoB2D,EAASD,EAAIE,GAC7B,OAAOD,GACH3C,OAAQ0C,EACRxC,OAAQ0C,IAER5C,OAAQ4C,EACR1C,OAAQwC,GAaOI,CAAWH,EAASD,EAAIE,SAIxCvE,EAAG8D,gBAAgB5B,EAAOK,EAAOpB,IAE5CrB,EAAU4E,aAAe,SAASC,EAAMxD,GACpC,GAAGwD,EAAKC,WACJ,OAAO5E,EAAG+D,gBAAgBY,EAAKC,WAAYzD,GAC1C,GAAGwD,EAAKzC,MACT,OAAOlC,EAAG8D,gBAAgBa,EAAKzC,MAAOyC,EAAKpC,MAAOpB,GACtD,MAAM,IAAI0D,MAAK,mCGnKnB/E,EAAUwC,SAAW,SAASqC,EAAM3B,GAChC,IAAI8B,EAAY9E,EAAG0E,aAAaC,EAAM3B,GAyBtC,OAvBI+B,YAAa,SAASC,EAAUC,GAC5B,IAAIC,GACAC,2BAA2B,EAC3B/C,KAAM,SAASgD,GACX,IAAIJ,EAASI,GAAK,CACd,IAAIzB,EAAImB,EAAUzC,KAAK+C,GACvBJ,EAASI,GAAMzB,EAAEhD,QAAQyB,KAAK8C,GAAOG,MAAM,KAAM1B,EAAEE,MAAMpD,IAAI,SAAS+B,GAClE,OAAO0C,EAAM9C,KAAKI,EAAEb,SAASjB,UAEjC4E,QAAQC,OAAOP,EAASI,IAE5B,OAAOJ,EAASI,IAEpBI,MAAO,SAASC,EAAWC,GACvB,IAAIF,EAAQP,EAAOQ,GACnB,OAAGD,EAAML,0BACEK,EAAMpD,KAAKsD,GACVF,EAAME,KAG1B,OAAOR,KFXnBpF,EAAU6F,QAAU,SAAShB,EAAMiB,GAC/B,IAAI7D,EAAW4C,EAAKrC,UAAYtC,EAAG0E,aAAaC,EAAKrC,UACjDuD,EAAS7F,EAAG0E,aAAaC,EAAKmB,WAC9B9D,GAAQK,QAAUqB,SAEtBmC,EAAO3D,QAAQkC,QAAQ,SAAS2B,GAC5B/D,EAAKK,KAAK0D,EAAMrF,QACZsF,WACAC,oBAiBRJ,EAAOtD,QAAQ6B,QAAQ,SAAS8B,GAC5B,IAAIC,EAAOD,EAAMxF,MAAO0F,EAASF,EAAMvF,QACnC0F,EAAKtE,GAAY6D,EAAUO,EAAKG,MAAK,KAAM,IAC3CC,EAASH,EAAOI,OACpB,GAAGD,GAAUA,EAAOE,OAAQ,CACxB,IAAIA,EAASF,EAAOE,OAAOJ,EAAIH,EAAON,GAEtCa,EArBR,SAAiBC,EAAMD,GACnB,OAAO,SAASzE,EAAM2E,EAAM1F,GACxB,IAAIsF,EAASE,EAAOzE,EAAM2E,EAAM1F,GAChC,OAAO,WACH,OAAOsF,EAAOlB,MAAM,KAAMqB,EAAKjG,IAAI,SAASmG,GACxC,IAAIC,EAAQD,EAAIN,MAAK,KACrB,OAAGO,EAAMC,OAAS,EACPH,EAAKnB,MAAMqB,EAAM,GAAIA,EAAM,IAE3BF,EAAKvE,KAAKwE,MACrBvB,MAAM,KAAM0B,aAWXC,CADE/G,EAASmG,EAAOM,MACJD,GACvBzE,EAAKK,KAAK6D,EAAMvE,SAASjB,OAAOsF,QAAQI,EAAOa,OAASjF,KAAMyE,MAGtEZ,EAAO3D,QAAQkC,QAAQ,SAAS2B,GAC5B,IAAImB,EAAOnB,EAAMrF,MACb2F,GAD6BN,EAAMpF,QAC9BoB,GAAY6D,EAAUsB,EAAKZ,MAAK,KAAM,KAC/CrG,EAAS8F,EAAMpF,SAASyD,QAAQ,SAASO,GACrCtE,EAAYsE,EAAKsB,eAAe7B,QAAQ,SAAS+C,GAC7CnF,EAAKK,KAAK6E,GAAMjB,cAAckB,EAASzG,KAAOyG,EAASxG,MAAM0F,EAAIN,KAErE1F,EAAYsE,EAAKqB,SAAS5B,QAAQ,SAASgD,GACvC,IAAIC,EAAMD,EAAQzG,MAAM0F,EAAIN,GAC5B/D,EAAKK,KAAK6E,GAAMlB,QAAQoB,EAAQ1G,MAC5B4G,SAAUD,EAAIC,SACdtF,KAAMqF,EAAIrF,UAItBA,EAAKK,KAAK6E,GAAMnG,KAAO,SAAS4F,EAAM1F,GAClC,IAAIsG,KAAcvB,EAAUhE,EAAKK,KAAK6E,GAAMlB,QAI5C,OAHAzF,OAAOC,KAAKwF,GAAS5B,QAAQ,SAAS6C,GAClCM,EAAQN,GAAQjB,EAAQiB,GAAMjF,KAAKA,EAAM2E,EAAM1F,KAE5CsG,KAIf,IAAIC,EAAU3B,EAAO3D,QAAQzB,IAAI,SAASkD,GACtC,IAAI8D,GAAM/G,IAAKiD,EAAEjD,MAAOC,UAAYsF,EAAgBjE,EAAKK,KAAKsB,EAAEjD,OAAOuF,cAIvE,OAHA1F,OAAOC,KAAKyF,GAAe7B,QAAQ,SAAS6C,GACxCQ,EAAG9G,MAAMsG,GAAQhB,EAAcgB,GAAMjF,KAAKA,KAEvCyF,IAEPC,EAAU7B,EAAOtD,QAAQ9B,IAAI,SAAS+B,GAE7BA,EAAE9B,MAEK8B,EAAEb,SAASjB,MACX8B,EAAEX,SAASnB,QAI/B,OAAOV,EAAGyC,MAAM+E,EAASE,IGxF7B5H,EAAU0F,MAAQ,SAASmC,GACvB,OACIvF,KAAM,SAASwF,GAEX,IAAIf,GADJc,EAAOA,GAAQC,EAAMlH,OACJ4F,MAAK,MACjBb,EAAWwB,GAAQJ,EAAMC,OAAS,EAAID,GAAQ,OAASc,GAC5D,OAAO,SAAS3F,GACZ,OAAO,SAAS2E,GACZ,OAAO,WACH,OAAOA,EAAKnB,MAAMC,EAAWwB,SAQrDnH,EAAU+H,OAAS,SAASZ,EAAMxB,GAC9B,OACIrD,KAAM,SAASwF,GACX,OAAO,SAAS5F,GACZ,OAAO,SAAS2E,GACZ,OAAO,SAASmB,GACZ,OAAOA,QAO/BhI,EAAUW,IAAM,WACZ,OACI2B,KAAM,SAASwF,GACX,IAAIG,EAAO9H,EAAS2H,EAAMjH,QAAQqH,MAAM,GACxC,OAAO,SAAShG,GACZ,OAAO,SAAS2E,GACZ,OAAO,SAASsB,GACZ,OAAOrH,EAAUqH,EACAjG,EAAKK,KAAK0F,GAAM/B,QAAQtF,IAAI4G,SAC5BtF,EAAKK,KAAK0F,GAAMhH,KAAKmH,KAAK,KAAMvB,UAOzE7G,EAAUqI,UAAY,WAClB,OACI/F,KAAM,SAASwF,GACX,OAAO,SAAS5F,GACZ,OAAO,SAAS2E,GACZ,OAAO,WACH,MAAM,IAAI9B,MAAK,mCAOvC/E,EAAUsI,KAAO,WACb,OACIhG,KAAM,SAASwF,GACX,IAAIG,EAAO9H,EAAS2H,EAAMjH,QAAQqH,MAAM,GACxC,OAAO,SAAShG,GACZ,OAAO,SAAS2E,GACZ,OAAO,SAASsB,EAAMxH,GAClB,OAAOwH,EAAKxH,IAAI,SAASQ,GACrB,OAAOR,EAAIuB,EAAKK,KAAK0F,GAAM/B,QAAQtF,IAAI4G,SAASrG,YAQ5EnB,EAAUuI,aAAe,SAASf,GAC9B,OACIlF,KAAM,SAASwF,GACX,OAAO,SAAS5F,GACZ,OAAO,SAAS2E,GACZ,OAAO,SAASsB,EAAMxH,GAClB,IAAIsH,EAAO9H,EAAS2H,EAAMjH,QAAQqH,MAAM,GACxC,OAAOC,EAAKjH,OAAO,SAASV,EAAGiD,GAC3B,IAAI7C,EAAM4G,EAAS/D,GAGnB,OAFWjD,EAAEI,GAAOJ,EAAEI,QACjB8C,KAAK/C,EAAIuB,EAAKK,KAAK0F,GAAM/B,QAAQtF,IAAI4G,SAAS/D,KAC5CjD,aAQnCR,EAAUwI,OAAS,WACf,OACIlG,KAAM,SAASwF,GACX,IAAIG,EAAO9H,EAAS2H,EAAMjH,QAAQqH,MAAM,GACxC,OAAO,SAAShG,GACZ,OAAO,SAAS2E,GACZ,OAAO,SAAS4B,EAAO/H,GACnB,IAAIgI,EAAM,IAAIC,IAAIjI,GAClB,OAAO+H,EAAMG,OAAO,SAASC,GACzB,OAAOH,EAAII,IAAI5G,EAAKK,KAAK0F,GAAM/B,QAAQtF,IAAI4G,SAASqB,YCvGhF7I,EAAU+I,WAAa,SAASC,GAC5B,OACI7C,eACI8C,OAAQ,SAAShH,EAAUgE,GACvB,OACI/D,KAAM,SAASA,GACX,IAAIgH,EAAQlH,EAAgBC,EAAUC,GACtC,OAAO,SAASiG,GACZ,IAAIgB,KACAtC,EAAOqC,EAAMjE,YAAYkE,GAAMhB,KAAMA,IAEzC,OADAgB,EAAIH,GAAW9G,EAAKK,KAAK0D,EAAMrF,OAAOK,KAAK4F,EAAMsB,EAAKlC,EAAMrF,QACrDuI,EAAIH,UAQvChJ,EAAUoJ,KAAO,SAASC,GACtB,OAAO,SAASC,GACZ,OACIpD,UACItF,IAAKyI,EACLxI,MAAO,SAASoB,EAAUgE,GACtB,OACIuB,SAAU8B,EACVpH,KAAM,SAASA,EAAM2E,EAAM1F,GACvB,OAAO,WACH,OAAOmI,EAAEnI,YASzCnB,EAAUY,IAAMV,EAAGkJ,KAAI,OACvBpJ,EAAUa,MAAQX,EAAGkJ,KAAI,SAGzBpJ,EAAUuJ,UAAY,SAAStD,GAC3B,OACIsD,UAAWtD,IAGnBjG,EAAUwJ,MAAQ,WACd,OACI7C,OAAQ,SAAS1E,EAAUmE,GACvB,OAAO,SAASlE,EAAM2E,GAClB,OAAO,SAASmB,GACZ,OAAO,WACH,OAAOA,QAO/BhI,EAAUyJ,UAAY,SAASC,GAC3B,OACI/C,OAAQ,SAAS1E,EAAUmE,GAEvB,OADAsD,EAASA,GAAU,CAAC1B,GAAKA,GAClB,SAAS9F,EAAM2E,EAAM1F,GACxB,OAAO,SAASR,GACZ,OAAO,SAASC,GACZ,OAAOD,EAAI+I,EAAO9I,UAO1CZ,EAAU2J,WAAa,SAASD,GAC5B,OACI/C,OAAQ,SAAS1E,EAAUmE,GACvB,OAAO,SAASlE,EAAM2E,EAAM1F,GACxB,OAAO,SAASR,GACZ,OAAO,WACH,OAAOA,EAAI+I,EAAOvI,UAO1CnB,EAAU4J,WAAa,WACnB,OACIjD,OAAQ,SAAS1E,EAAUmE,GACvB,OAAO,SAASlE,EAAM2E,EAAM1F,GACxB,OAAO,SAASR,GACZ,OAAO,WACH,OAAOA,EAAIuB,EAAKK,KAAK6D,EAAMvE,SAASjB,OAAOsF,QAAQtF,IAAI4G,SAASrG,cAOxFnB,EAAU6J,SAAW,WACjB,OACIlD,OAAQ,SAAS1E,EAAUmE,EAAON,GAC9B,OAAO,SAAS5D,EAAM2E,EAAM1F,GACxB,IAAI2I,EAAU9H,EAAgBC,EAAUC,GAAO6H,EAAUD,EACrD/C,EAAQX,EAAMrE,SAASnB,MAAM4F,MAAK,KACtC,GAAGO,EAAMC,OAAS,EAAG,CACjB,IAAIgD,EAAOjD,EAAM,GACjBgD,EAAU/H,EAAgB8D,EAAUkE,GAAO9H,GAE/C,OAAO,WACH,OAAO,SAAS+H,EAAUC,EAAUC,GAEhC,IAAIC,EAASN,EAAQ7E,gBACjBkD,MACI8B,SAAUA,EACVC,SAAUA,GAEdG,OAAQxD,IACRyD,KACAC,EAAQR,EAAQ9E,YAAYqF,GAC5BnC,KAAMiC,IAGV,OADAE,EAAK3H,MAAQT,EAAKK,KAAK6D,EAAMrE,SAASnB,OAAOK,KAAKsJ,EAAOJ,GAClDG,EAAK3H,YC5HpC3C,EAAUwK,cAAgB,SAASnJ,GAC/B,IAAI6B,EAAU9B,EAAcC,GAC5B,OACImB,UACIsC,YACI1C,OAAQG,KAAMrC,EAAGwF,SACjBjD,OAAQF,KAAMrC,EAAGwF,SACjB+E,aACIlI,KAAMrC,EAAGS,MACTuH,KAAM,OACNnE,IAAK,SAET2G,aACInI,KAAMrC,EAAGS,MACTuH,KAAM,OACNnE,IAAK,SAETpB,OAAQJ,KAAMrC,EAAGmI,aACjBsC,WACIpI,KAAMrC,EAAGoI,OACTJ,KAAM,OACNnE,KAAK,QAAU,gBAEnB6G,WACIrI,KAAMrC,EAAGoI,OACTJ,KAAM,OACNnE,KAAK,QAAU,gBAEnB8G,WACItI,KAAMrC,EAAGqI,aAAarF,EAAQtB,YAC9BsG,KAAM,OACNnE,KAAK,QAAU,gBAEnB+G,UACIvI,KAAMrC,EAAGqI,aAAarF,EAAQpB,YAC9BoG,KAAM,OACNnE,KAAK,QAAU,kBAI3BiC,WACI5D,OACI2I,MAAO7K,EAAG6I,WAAU,SACpBiC,MAAO9K,EAAGU,IAAIsC,EAAQ3B,SAAUrB,EAAGW,MAAMqC,EAAQxB,YACjDuJ,MAAO/K,EAAGU,IAAIsC,EAAQzB,SAAUvB,EAAGW,MAAMqC,EAAQvB,aAErDc,OACIyI,YACI/D,KAAM,OACNtF,OAAQ,QAASE,OAAQ,OACzB6E,KAAM,cACNF,OAAQxG,EAAGuJ,aAEf0B,YACIhE,KAAM,QACNtF,OAAQ,OAAQE,OAAQ,QACxB6E,KAAM,QACNF,OAAQxG,EAAGsJ,SAEf4B,aACIjE,KAAM,QACNtF,OAAQ,QAASE,OAAQ,OACzB6E,KAAM,YACNF,OAAQxG,EAAGsJ,SAEf6B,YACIlE,KAAM,OACNtF,OAAQ,QAASE,OAAQ,OACzB6E,KAAM,cACNF,OAAQxG,EAAGuJ,aAEf6B,YACInE,KAAM,QACNtF,OAAQ,OAAQE,OAAQ,QACxB6E,KAAM,QACNF,OAAQxG,EAAGsJ,SAEf+B,aACIpE,KAAM,QACNtF,OAAQ,QAASE,OAAQ,OACzB6E,KAAM,YACNF,OAAQxG,EAAGsJ,SAEfgC,aACIrE,KAAM,SACNtF,OAAQ,OAAQE,OAAQ,OACxB6E,KAAM,cACNF,OAAQxG,EAAGyJ,WAAWzG,EAAQtB,aAElC6J,aACItE,KAAM,SACNtF,OAAQ,OAAQE,OAAQ,OACxB6E,KAAM,cACNF,OAAQxG,EAAGyJ,WAAWzG,EAAQpB,aAElC+I,WACI1D,KAAM,OACNtF,OAAQ,OAAQE,OAAQ,OACxB6E,KAAM,YACNF,OAAQxG,EAAG0J,cAEfkB,UACI3D,KAAM,MACNtF,OAAQ,OAAQE,OAAQ,OACxB6E,KAAM,WACNF,OAAQxG,EAAG0J,kBCzG/B5J,EAAU0L,iBAAmB,SAASrK,GACpBD,EAAcC,GAC5B,OACImB,UACIsC,YACI6G,cAAepJ,KAAMrC,EAAGwF,MAAK,iBAC7BkG,cAAerJ,KAAMrC,EAAGwF,MAAK,iBAC7BmG,WAAYtJ,KAAMrC,EAAGwF,MAAK,aAC1BoG,WAAYvJ,KAAMrC,EAAGwF,MAAK,aAC1BqG,cACIxJ,KAAMrC,EAAGsI,SACTN,KAAM,aACNnE,KAAK,eAAiB,cAE1BiI,cACIzJ,KAAMrC,EAAGsI,SACTN,KAAM,aACNnE,KAAK,eAAiB,cAE1B3B,OACIG,KAAMrC,EAAG6H,SACThE,IAAK,gBAETtB,OACIF,KAAMrC,EAAG6H,SACThE,IAAK,kBAIjBiC,WACI5D,OACI6J,YAAa,eACbC,WAAY,eAEhBzJ,OACIoH,UACI1C,KAAM,WACNtF,OAAQ,cAAeE,OAAQ,aAC/B2E,OAAQxG,EAAG2J,YAEfsC,SACIhF,KAAM,UACNtF,OAAQ,cAAeE,OAAQ,aAC/B6E,KAAM,qBACNF,OAAQxG,EAAGuJ,aAEf2C,SACIjF,KAAM,UACNtF,OAAQ,cAAeE,OAAQ,aAC/B6E,KAAM,qBACNC,KAAM3G,EAAGuJ,aAEb4C,WACIlF,KAAM,WACNtF,OAAQ,aAAcE,OAAQ,cAC9B2E,OAAQxG,EAAG2J,YAEfyC,UACInF,KAAM,UACNtF,OAAQ,aAAcE,OAAQ,cAC9B6E,KAAM,cACNF,OAAQxG,EAAGuJ,UAAUzB,GAAKA,EAAEpH,QAEhC2L,UACIpF,KAAM,UACNtF,OAAQ,aAAcE,OAAQ,cAC9B6E,KAAM,cACNC,KAAM3G,EAAGuJ,UAAUzB,GAAKA,EAAEpH,YCnE9CZ,EAAUwM,iBAAmB,SAAS7J,GAElC,IAAI8J,KAAcC,KAAaC,KAC/B,SAASC,EAAM/I,GACX,GAAG4I,EAAQ5I,EAAEjD,OACT,MAAM,IAAImE,MAAK,aACf2H,EAAO7I,EAAEjD,SACT6L,EAAQ5I,EAAEjD,QAAS,EACnBiD,EAAEC,OAAOQ,QAAQ,SAAS5B,GACtBkK,EAAMlK,EAAEX,YAEZ2K,EAAO7I,EAAEjD,QAAS,EAClB6L,EAAQ5I,EAAEjD,QAAS,EACnB+L,EAAOE,QAAQhJ,IAIvB,IADA,IAAIiJ,EAAI,EACFrM,OAAOC,KAAKgM,GAAQ1F,OAASrE,EAAMP,QAAQ4E,QAAQ,CACrD,KAAM0F,EAAO/J,EAAMP,QAAQ0K,GAAGlM,UAAUkM,EACxCF,EAAMjK,EAAMP,QAAQ0K,IAExB,OAAOH,GCrBX3M,EAAU+M,QAAU,SAASC,GACzB,IAAIL,EAASzM,EAAGsM,iBAAiBQ,GAC7BC,KAAYnH,KAChB,SAASoH,EAAWC,EAAShG,GACzB,OAAOgG,EAAQpJ,MAAMqJ,KAAKC,GAAMA,EAAGxM,QAAQ6E,QAAUyB,GAGzDwF,EAAOrI,QAAQ,SAAS6I,GACpB,IAAIlL,EAAW/B,EAAG0E,aAAauI,EAAQtM,QAAQ2B,UAC3C8K,EAASrL,EAASG,QAAQzB,IAAI,SAAS4M,GACvC,IAAIC,EAAK/M,OAAOa,UAAWiM,EAAG1M,SAS9B,OARA2M,EAAGtF,KAAO/H,EAASqN,EAAGtF,MAAMvH,IAAI,SAAS8M,GACrC,IAAI1G,EAAQ0G,EAAIjH,MAAK,KACrB,OAAGO,EAAMC,OAAS,EACAkG,EAAWC,EAASpG,EAAM,IACzBlF,SAASjB,MAAQ,IAAMmG,EAAM,GAEpCoG,EAAQvM,MAAQ,IAAMmG,EAAM,MAGxCnG,IAAK2M,EAAG3M,MACRC,MAAO2M,KAGXE,EAASzL,EAASQ,QAAQ9B,IAAI+B,KAAO9B,IAAK8B,EAAE9B,MAAOC,MAAO6B,EAAE7B,WAChEiF,EAAUqH,EAAQvM,OAASV,EAAGyC,MAAM2K,EAAQI,GAC5C,IAAI3H,EAASoH,EAAQtM,QAAQmF,UAC7BiH,EAAME,EAAQvM,OAASV,EAAG0E,cACtBxC,MAAO2D,EAAO3D,MACdK,MAAOsD,EAAOtD,UAItB,IAAIL,KAAYK,KAAYkL,KAC5B,SAASC,EAAOhN,GACZ,OAAO+M,EAAS/M,IAAQA,EA4B5B,OA1BA+L,EAAOrI,QAAQ,SAAS6I,GACpB,IAAItH,EAAUoH,EAAME,EAAQvM,OAC5BiF,EAAQzD,QAAQkC,QAAQ,SAAS2B,GAC7B,IAAIrF,EAAMuM,EAAQvM,MAAQ,IAAMqF,EAAMrF,MAClC6M,EAAMtN,EAAS8F,EAAMpF,SAASuM,KAAKvI,GAAwB,iBAATA,GACtD,GAAG4I,EAAK,CACJ,IAAI1G,EAAQ0G,EAAIjH,MAAK,KAEjBqH,EAAOD,EADGV,EAAWC,EAASpG,EAAM,IACdlF,SAASjB,MAAQ,IAAMmG,EAAM,IACvD4G,EAAS/M,GAAOiN,OAEfzL,EAAMsB,MACP9C,IAAKA,EACLC,MAAOoF,EAAMpF,YAGrBgF,EAAQpD,QAAQ6B,QAAQ,SAAS8B,GAC7B,IAAI0H,EAAOrN,OAAOa,UAAW8E,EAAMvF,SACnCiN,EAAKjM,OAAS+L,EAAOT,EAAQvM,MAAQ,IAAMwF,EAAMvE,SAASjB,OAC1DkN,EAAK/L,OAAS6L,EAAOT,EAAQvM,MAAQ,IAAMwF,EAAMrE,SAASnB,OAC1D6B,EAAMiB,MACF9C,IAAKuM,EAAQvM,MAAQ,IAAMwF,EAAMxF,MACjCC,MAAOiN,QAIZ5N,EAAG2F,SACNG,WACI5D,MAAAA,EACAK,MAAAA,IAELqD,IPpEA9F,EAEmB,mBAAX+N,QAAyBA,OAAOC,IACvCD,UAAWhO,GACa,iBAAVkO,QAAsBA,OAAOC,QAC3CD,OAAOC,QAAUnO,IAEjBoO,KAAKnO,UAAYD,IJPzB","file":"metagraph.min.js","sourcesContent":["(function() { function _metagraph() {\n'use strict';\n","var metagraph = {\n    version: '0.0.7'\n};\nvar mg = metagraph;\n\nfunction as_array(a) {\n    return !a && [] || (Array.isArray(a) ? a : [a]);\n}\n\nfunction as_keyvalue(o) {\n    return !o && [] || (Array.isArray(o) ? o : Object.keys(o).map(function(key) {\n        return {key: key, value: o[key]};\n    }));\n}\n\nfunction build_map(vals, keyf, wrap) {\n    return vals.reduce(function(o, val) {\n        o[keyf(val)] = wrap(val);\n        return o;\n    }, {});\n}\n","function graph_options(opts) {\n    return Object.assign({\n        nodeKey: function(kv) { return kv.key; },\n        edgeKey: function(kv) { return kv.key; },\n        nodeValue: function(kv) { return kv.value; },\n        edgeValue: function(kv) { return kv.value; },\n        edgeSource: function(kv) { return kv.value.source; },\n        edgeTarget: function(kv) { return kv.value.target; }\n    }, opts || {});\n}\nmetagraph.graph = function(nodes, edges, opts) {\n    nodes = as_keyvalue(nodes);\n    edges = as_keyvalue(edges);\n    var options = graph_options(opts);\n\n    var _nodeMap, _edgeMap, _nodesList, _edgesList, _outsList, _insList;\n\n    function build_node_map() {\n        if(_nodeMap)\n            return;\n        _nodeMap = build_map(nodes, options.nodeKey, node_wrapper);\n    }\n    function build_edge_map() {\n        if(_edgeMap)\n            return;\n        _edgeMap = build_map(edges, options.edgeKey, edge_wrapper);\n    }\n    function build_nodes_list() {\n        if(_nodesList)\n            return;\n        build_node_map();\n        _nodesList = nodes.map(function(v) { return _graph.node(options.nodeKey(v)); });\n    }\n    function build_edges_list() {\n        if(_edgesList)\n            return;\n        build_edge_map();\n        _edgesList = edges.map(function(v) { return _graph.edge(options.edgeKey(v)); });\n    }\n    function build_directional_edge_lists(acc) {\n        build_edge_map();\n        return edges.reduce(function(o, v) {\n            var l = o[acc(v)] = o[acc(v)] || [];\n            l.push(_graph.edge(options.edgeKey(v)));\n            return o;\n        }, {});\n    }\n    function build_outs_map() {\n        if(_outsList)\n            return;\n        _outsList = build_directional_edge_lists(options.edgeSource);\n    }\n    function build_ins_map() {\n        if(_insList)\n            return;\n        _insList = build_directional_edge_lists(options.edgeTarget);\n    }\n    function node_wrapper(n) {\n        return {\n            value: function() {\n                return options.nodeValue(n);\n            },\n            key: function() {\n                return options.nodeKey(n);\n            },\n            graph: function() {\n                return _graph;\n            },\n            outs: function() {\n                build_outs_map();\n                return _outsList[options.nodeKey(n)] || [];\n            },\n            ins: function() {\n                build_ins_map();\n                return _insList[options.nodeKey(n)] || [];\n            }\n        };\n    }\n    function edge_wrapper(e) {\n        return {\n            value: function() {\n                return options.edgeValue(e);\n            },\n            key: function() {\n                return options.edgeKey(e);\n            },\n            graph: function() {\n                return _graph;\n            },\n            source: function() {\n                return _graph.node(options.edgeSource(e));\n            },\n            target: function() {\n                return _graph.node(options.edgeTarget(e));\n            }\n        };\n    }\n    var _graph = {\n        node: function(key) {\n            build_node_map();\n            return _nodeMap[key];\n        },\n        edge: function(key) {\n            build_edge_map();\n            return _edgeMap[key];\n        },\n        nodes: function() {\n            build_nodes_list();\n            return _nodesList;\n        },\n        edges: function() {\n            build_edges_list();\n            return _edgesList;\n        }\n    };\n    return _graph;\n};\n\nmetagraph.graph_adjacency = metagraph.graph;\nfunction incidence_options(opts) {\n    var gropts = graph_options(opts);\n    return Object.assign({\n        nodeIncidences: n => n && (n.edges || n.ins || n.outs) || [],\n        incidencesOutward: n => {\n            var v = gropts.nodeValue(n);\n            return !v /* doesn't matter */ || !!(v.edges || v.outs);\n        }\n    }, gropts);\n}\nmetagraph.graph_incidence = function(nodes, opts) {\n    nodes = as_keyvalue(nodes);\n    var options = incidence_options(opts);\n    var edges = [];\n    function edge_value(outward, nk, ik) {\n        return outward ? {\n            source: nk,\n            target: ik\n        } : {\n            source: ik,\n            target: nk\n        };\n    }\n    function edge_key(outward, nk, ik) {\n        return outward ? nk + '-' + ik : ik + '-' + nk;\n    }\n    nodes.forEach(function(n) {\n        var nk = options.nodeKey(n),\n            outward = options.incidencesOutward(n);\n        as_array(options.nodeIncidences(options.nodeValue(n)))\n            .forEach(function(ik) {\n                edges.push({\n                    key: edge_key(outward, nk, ik),\n                    value: edge_value(outward, nk, ik)\n                });\n            });\n    });\n    return mg.graph_adjacency(nodes, edges, opts);\n};\nmetagraph.graph_detect = function(spec, opts) {\n    if(spec.incidences)\n        return mg.graph_incidence(spec.incidences, opts);\n    else if(spec.nodes)\n        return mg.graph_adjacency(spec.nodes, spec.edges, opts);\n    throw new Error('did not recognize graph format');\n};\n","/**\n * The reason there are so many higher-order functions is that there are five\n * stages of a pattern's life:\n * - specification - the pattern author specifies a pattern in terms of its dataflow and\n *   interface. the pattern is parameterized on user-supplied data accessors\n * - definition (compilation) - the pattern walks the resulting graph and\n *   defines the functions that will respond to data\n * - instantiation - data is provided to the pattern to create objects\n * - binding - if the action needs other indices built, they are built on demand\n *   and provided to the action before it's run\n * - action - responding to user code\n **/\nmetagraph.pattern = function(spec, flowspecs) {\n    var flowspec = spec.dataflow && mg.graph_detect(spec.dataflow),\n        interf = mg.graph_detect(spec.interface);\n    var defn = {node: {}, edge: {}};\n\n    interf.nodes().forEach(function(inode) {\n        defn.node[inode.key()] = {\n            members: {},\n            class_members: {}\n        };\n    });\n    function resolve(deps, funfun) {\n        return function(defn, flow, val) {\n            var action = funfun(defn, flow, val);\n            return function() {\n                return action.apply(null, deps.map(function(dep) {\n                    var parts = dep.split('.');\n                    if(parts.length > 1)\n                        return flow.input(parts[0], parts[1]);\n                    else\n                        return flow.calc(dep);\n                })).apply(null, arguments);\n            };\n        };\n    }\n    interf.edges().forEach(function(iedge) {\n        var ekey = iedge.key(), evalue = iedge.value();\n        var fs = flowspec || flowspecs[ekey.split('.')[0]];\n        var action = evalue.member;\n        if(action && action.funfun) {\n            var funfun = action.funfun(fs, iedge, flowspecs);\n            var deps = as_array(evalue.deps);\n            funfun = resolve(deps, funfun);\n            defn.node[iedge.source().key()].members[evalue.name] = {defn: funfun};\n        }\n    });\n    interf.nodes().forEach(function(inode) {\n        var nkey = inode.key(), nvalue = inode.value();\n        var fs = flowspec || flowspecs[nkey.split('.')[0]];\n        as_array(inode.value()).forEach(function(spec) {\n            as_keyvalue(spec.class_members).forEach(function(cmemspec) {\n                defn.node[nkey].class_members[cmemspec.key] = cmemspec.value(fs, inode);\n            });\n            as_keyvalue(spec.members).forEach(function(memspec) {\n                var mem = memspec.value(fs, inode);\n                defn.node[nkey].members[memspec.key] = {\n                    accessor: mem.accessor,\n                    defn: mem.defn\n                };\n            });\n        });\n        defn.node[nkey].wrap = function(flow, val) {\n            var wrapper = {}, members = defn.node[nkey].members;\n            Object.keys(members).forEach(function(name) {\n                wrapper[name] = members[name].defn(defn, flow, val);\n            });\n            return wrapper;\n        };\n    });\n\n    var inodes2 = interf.nodes().map(function(n) {\n        var n2 = {key: n.key(), value: {}}, class_members = defn.node[n.key()].class_members;\n        Object.keys(class_members).forEach(function(name) {\n            n2.value[name] = class_members[name].defn(defn);\n        });\n        return n2;\n    });\n    var iedges2 = interf.edges().map(function(e) {\n        var e2 = {\n            key: e.key(),\n            value: {\n                source: e.source().key(),\n                target: e.target().key()\n            }\n        };\n    });\n    return mg.graph(inodes2, iedges2);\n};\n\nfunction define_dataflow(flowspec, defn) {\n    var flownodes = flowspec.nodes().map(function(fsn) {\n        return {\n            key: fsn.key(),\n            value: {\n                calc: fsn.value().node.calc(fsn)(defn)\n            }\n        };\n    });\n    return mg.dataflow({\n        nodes: flownodes,\n        edges: flowspec.edges().map(e => ({key: e.key(), value: e.value()}))\n    });\n}\n","return metagraph;\n}\n    if (typeof define === 'function' && define.amd) {\n        define([], _metagraph);\n    } else if (typeof module == \"object\" && module.exports) {\n        module.exports = _metagraph();\n    } else {\n        this.metagraph = _metagraph();\n    }\n}\n)();\n","metagraph.dataflow = function(spec, options) {\n    var flowgraph = mg.graph_detect(spec, options);\n    var _flow = {\n        instantiate: function(instance, inputs) {\n            var _inst = {\n                _yes_i_am_really_dataflow: true,\n                calc: function(id) {\n                    if(!instance[id]) {\n                        var n = flowgraph.node(id);\n                        instance[id] = n.value().calc(_inst).apply(null, n.ins().map(function(e) {\n                            return _inst.calc(e.source().key());\n                        }));\n                        console.assert(instance[id]);\n                    }\n                    return instance[id];\n                },\n                input: function(namespace, field) {\n                    var input = inputs[namespace];\n                    if(input._yes_i_am_really_dataflow)\n                        return input.calc(field);\n                    else return input[field];\n                }\n            };\n            return _inst;\n        }\n    };\n    return _flow;\n};\n","metagraph.input = function(path) {\n    return {\n        calc: function(fnode) {\n            path = path || fnode.key();\n            var parts = path.split('.');\n            var [namespace, name] = parts.length > 1 ? parts : ['data', path];\n            return function(defn) {\n                return function(flow) {\n                    return function() {\n                        return flow.input(namespace, name);\n                    };\n                };\n            };\n        }\n    };\n};\n// pass-through\nmetagraph.output = function(name, namespace) {\n    return {\n        calc: function(fnode) {\n            return function(defn) {\n                return function(flow) {\n                    return function(x) {\n                        return x;\n                    };\n                };\n            };\n        }\n    };\n};\nmetagraph.map = function() {\n    return {\n        calc: function(fnode) {\n            var iref = as_array(fnode.value().refs)[0];\n            return function(defn) {\n                return function(flow) {\n                    return function(data) {\n                        return build_map(data,\n                                         defn.node[iref].members.key.accessor,\n                                         defn.node[iref].wrap.bind(null, flow));\n                    };\n                };\n            };\n        }\n    };\n};\nmetagraph.singleton = function() {\n    return {\n        calc: function(fnode) {\n            return function(defn) {\n                return function(flow) {\n                    return function() {\n                        throw new Error('singleton not initialized');\n                    };\n                };\n            };\n        }\n    };\n};\nmetagraph.list = function() {\n    return {\n        calc: function(fnode) {\n            var iref = as_array(fnode.value().refs)[0];\n            return function(defn) {\n                return function(flow) {\n                    return function(data, map) {\n                        return data.map(function(val) {\n                            return map[defn.node[iref].members.key.accessor(val)];\n                        });\n                    };\n                };\n            };\n        }\n    };\n};\nmetagraph.map_of_lists = function(accessor) {\n    return {\n        calc: function(fnode) {\n            return function(defn) {\n                return function(flow) {\n                    return function(data, map) {\n                        var iref = as_array(fnode.value().refs)[0];\n                        return data.reduce(function(o, v) {\n                            var key = accessor(v);\n                            var list = o[key] = o[key] || [];\n                            list.push(map[defn.node[iref].members.key.accessor(v)]);\n                            return o;\n                        }, {});\n                    };\n                };\n            };\n        }\n    };\n};\nmetagraph.subset = function() {\n    return {\n        calc: function(fnode) {\n            var iref = as_array(fnode.value().refs)[0];\n            return function(defn) {\n                return function(flow) {\n                    return function(items, keys) {\n                        var set = new Set(keys);\n                        return items.filter(function(r) {\n                            return set.has(defn.node[iref].members.key.accessor(r));\n                        });\n                    };\n                };\n            };\n        }\n    };\n};\n","metagraph.createable = function(flowkey) {\n    return {\n        class_members: {\n            create: function(flowspec, inode) {\n                return {\n                    defn: function(defn) {\n                        var flowg = define_dataflow(flowspec, defn);\n                        return function(data) {\n                            var env = {};\n                            var flow = flowg.instantiate(env, {data: data});\n                            env[flowkey] = defn.node[inode.key()].wrap(flow, data[inode.key()]);\n                            return env[flowkey];\n                        };\n                    }\n                };\n            }\n        }\n    };\n};\nmetagraph.call = function(methodname) {\n    return function(f) {\n        return {\n            members: [{\n                key: methodname,\n                value: function(flowspec, inode) {\n                    return {\n                        accessor: f,\n                        defn: function(defn, flow, val) {\n                            return function() {\n                                return f(val);\n                            };\n                        }\n                    };\n                }\n            }]\n        };\n    };\n};\nmetagraph.key = mg.call('key');\nmetagraph.value = mg.call('value');\n\n// interface edges\nmetagraph.reference = function(inode) {\n    return {\n        reference: inode\n    };\n};\nmetagraph.fetch = function() {\n    return {\n        funfun: function(flowspec, iedge) {\n            return function(defn, flow) {\n                return function(x) {\n                    return function() {\n                        return x;\n                    };\n                };\n            };\n        }\n    };\n};\nmetagraph.lookupArg = function(access) {\n    return {\n        funfun: function(flowspec, iedge) {\n            access = access || (x => x);\n            return function(defn, flow, val) {\n                return function(map) {\n                    return function(key) {\n                        return map[access(key)];\n                    };\n                };\n            };\n        }\n    };\n};\nmetagraph.lookupFVal = function(access) {\n    return {\n        funfun: function(flowspec, iedge) {\n            return function(defn, flow, val) {\n                return function(map) {\n                    return function() {\n                        return map[access(val)];\n                    };\n                };\n            };\n        }\n    };\n};\nmetagraph.lookupKVal = function() {\n    return {\n        funfun: function(flowspec, iedge) {\n            return function(defn, flow, val) {\n                return function(map) {\n                    return function() {\n                        return map[defn.node[iedge.source().key()].members.key.accessor(val)] || [];\n                    };\n                };\n            };\n        }\n    };\n};\nmetagraph.subgraph = function() {\n    return {\n        funfun: function(flowspec, iedge, flowspecs) {\n            return function(defn, flow, val) {\n                var subflow = define_dataflow(flowspec, defn), graflow = subflow;\n                var parts = iedge.target().key().split('.');\n                if(parts.length > 1) {\n                    var dest = parts[0];\n                    graflow = define_dataflow(flowspecs[dest], defn);\n                }\n                return function() {\n                    return function(nodeKeys, edgeKeys, gdata) {\n                        // two environments, one for the sub-pattern and one for the graph pattern\n                        var sgflow = subflow.instantiate({}, {\n                            data: {\n                                nodeKeys: nodeKeys,\n                                edgeKeys: edgeKeys\n                            },\n                            parent: flow});\n                        var genv = {};\n                        var gflow = graflow.instantiate(genv, {\n                            data: sgflow\n                        });\n                        genv.graph = defn.node[iedge.target().key()].wrap(gflow, gdata);\n                        return genv.graph;\n                    };\n                };\n            };\n        }\n    };\n};\n\n","metagraph.graph_pattern = function(opts) {\n    var options = graph_options(opts);\n    return {\n        dataflow: {\n            incidences: {\n                nodes: {node: mg.input()},\n                edges: {node: mg.input()},\n                node_by_key: {\n                    node: mg.map(),\n                    refs: 'Node',\n                    ins: 'nodes'\n                },\n                edge_by_key: {\n                    node: mg.map(),\n                    refs: 'Edge',\n                    ins: 'edges'\n                },\n                graph: {node: mg.singleton()},\n                node_list: {\n                    node: mg.list(),\n                    refs: 'Node',\n                    ins: ['nodes', 'node_by_key']\n                },\n                edge_list: {\n                    node: mg.list(),\n                    refs: 'Edge',\n                    ins: ['edges', 'edge_by_key']\n                },\n                node_outs: {\n                    node: mg.map_of_lists(options.edgeSource),\n                    refs: 'Node',\n                    ins: ['edges', 'edge_by_key']\n                },\n                node_ins: {\n                    node: mg.map_of_lists(options.edgeTarget),\n                    refs: 'Node',\n                    ins: ['edges', 'edge_by_key']\n                }\n            }\n        },\n        interface: {\n            nodes: {\n                Graph: mg.createable('graph'),\n                Node: [mg.key(options.nodeKey), mg.value(options.nodeValue)],\n                Edge: [mg.key(options.edgeKey), mg.value(options.edgeValue)]\n            },\n            edges: {\n                graph_node: {\n                    name: 'node',\n                    source: 'Graph', target: 'Node',\n                    deps: 'node_by_key',\n                    member: mg.lookupArg()\n                },\n                node_graph: {\n                    name: 'graph',\n                    source: 'Node', target: 'Graph',\n                    deps: 'graph',\n                    member: mg.fetch()\n                },\n                graph_nodes: {\n                    name: 'nodes',\n                    source: 'Graph', target: 'Node',\n                    deps: 'node_list',\n                    member: mg.fetch()\n                },\n                graph_edge: {\n                    name: 'edge',\n                    source: 'Graph', target: 'Edge',\n                    deps: 'edge_by_key',\n                    member: mg.lookupArg()\n                },\n                edge_graph: {\n                    name: 'graph',\n                    source: 'Edge', target: 'Graph',\n                    deps: 'graph',\n                    member: mg.fetch()\n                },\n                graph_edges: {\n                    name: 'edges',\n                    source: 'Graph', target: 'Edge',\n                    deps: 'edge_list',\n                    member: mg.fetch()\n                },\n                edge_source: {\n                    name: 'source',\n                    source: 'Edge', target: 'Node',\n                    deps: 'node_by_key',\n                    member: mg.lookupFVal(options.edgeSource)\n                },\n                edge_target: {\n                    name: 'target',\n                    source: 'Edge', target: 'Node',\n                    deps: 'node_by_key',\n                    member: mg.lookupFVal(options.edgeTarget)\n                },\n                node_outs: {\n                    name: 'outs',\n                    source: 'Node', target: 'Edge',\n                    deps: 'node_outs',\n                    member: mg.lookupKVal()\n                },\n                node_ins: {\n                    name: 'ins',\n                    source: 'Node', target: 'Edge',\n                    deps: 'node_ins',\n                    member: mg.lookupKVal()\n                }\n            }\n        }\n    };\n};\n","metagraph.subgraph_pattern = function(opts) {\n    var options = graph_options(opts);\n    return {\n        dataflow: {\n            incidences: {\n                parent_nodes: {node: mg.input('parent.nodes')},\n                parent_edges: {node: mg.input('parent.edges')},\n                node_keys: {node: mg.input('nodeKeys')},\n                edge_keys: {node: mg.input('edgeKeys')},\n                subset_nodes: {\n                    node: mg.subset(),\n                    refs: 'child.Node',\n                    ins: ['parent_nodes', 'node_keys']\n                },\n                subset_edges: {\n                    node: mg.subset(),\n                    refs: 'child.Edge',\n                    ins: ['parent_edges', 'edge_keys']\n                },\n                nodes: {\n                    node: mg.output(),\n                    ins: 'subset_nodes'\n                },\n                edges: {\n                    node: mg.output(),\n                    ins: 'subset_edges'\n                }\n            }\n        },\n        interface: {\n            nodes: {\n                ParentGraph: 'parent.Graph',\n                ChildGraph: 'child.Graph'\n            },\n            edges: {\n                subgraph: {\n                    name: 'subgraph',\n                    source: 'ParentGraph', target: 'ChildGraph',\n                    member: mg.subgraph()\n                },\n                subnode: {\n                    name: 'subnode',\n                    source: 'ParentGraph', target: 'ChildGraph',\n                    deps: 'parent.node_by_key',\n                    member: mg.lookupArg()\n                },\n                subedge: {\n                    name: 'subedge',\n                    source: 'ParentGraph', target: 'ChildGraph',\n                    deps: 'parent.edge_by_key',\n                    flow: mg.lookupArg()\n                },\n                subgraphS: {\n                    name: 'subgraph',\n                    source: 'ChildGraph', target: 'ParentGraph',\n                    member: mg.subgraph()\n                },\n                subnodeS: {\n                    name: 'subnode',\n                    source: 'ChildGraph', target: 'ParentGraph',\n                    deps: 'node_by_key', // should be child:\n                    member: mg.lookupArg(x => x.key())\n                },\n                subedgeS: {\n                    name: 'subedge',\n                    source: 'ChildGraph', target: 'ParentGraph',\n                    deps: 'edge_by_key', // should be child:\n                    flow: mg.lookupArg(x => x.key())\n                }\n            }\n        }\n    };\n};\n","metagraph.topological_sort = function(graph) {\n    // https://en.wikipedia.org/wiki/Topological_sorting#Depth-first_search\n    var stacked = {}, marked = {}, sorted = [];\n    function visit(n) {\n        if(stacked[n.key()])\n            throw new Error('not a DAG');\n        if(!marked[n.key()]) {\n            stacked[n.key()] = true;\n            n.outs().forEach(function(e) {\n                visit(e.target());\n            });\n            marked[n.key()] = true;\n            stacked[n.key()] = false;\n            sorted.unshift(n);\n        }\n    }\n    var i = 0;\n    while(Object.keys(marked).length < graph.nodes().length) {\n        while(marked[graph.nodes()[i].key()]) ++i;\n        visit(graph.nodes()[i]);\n    }\n    return sorted;\n};\n\n","metagraph.compose = function(composition) {\n    var sorted = mg.topological_sort(composition);\n    var built = {}, flowspecs = {};\n    function input_edge(patnode, name) {\n        return patnode.ins().find(pe => pe.value().input === name);\n    }\n    // resolve dependencies and build patterns\n    sorted.forEach(function(patnode) {\n        var flowspec = mg.graph_detect(patnode.value().dataflow);\n        var fnodes = flowspec.nodes().map(function(fn) {\n            var v2 = Object.assign({}, fn.value());\n            v2.refs = as_array(v2.refs).map(function(ref) {\n                var parts = ref.split('.');\n                if(parts.length > 1) {\n                    var patedge = input_edge(patnode, parts[0]);\n                    return patedge.source().key() + '.' + parts[1];\n                }\n                else return patnode.key() + '.' + parts[0];\n            });\n            return {\n                key: fn.key(),\n                value: v2\n            };\n        });\n        var fedges = flowspec.edges().map(e => ({key: e.key(), value: e.value()}));\n        flowspecs[patnode.key()] = mg.graph(fnodes, fedges);\n        var interf = patnode.value().interface;\n        built[patnode.key()] = mg.graph_detect({\n            nodes: interf.nodes,\n            edges: interf.edges\n        });\n    });\n    // unite patterns\n    var nodes = [], edges = [], mappings = {};\n    function lookup(key) {\n        return mappings[key] || key;\n    }\n    sorted.forEach(function(patnode) {\n        var pattern = built[patnode.key()];\n        pattern.nodes().forEach(function(inode) {\n            var key = patnode.key() + '.' + inode.key();\n            var ref = as_array(inode.value()).find(spec => typeof spec === 'string');\n            if(ref) {\n                var parts = ref.split('.');\n                var patedge = input_edge(patnode, parts[0]);\n                var key2 = lookup(patedge.source().key() + '.' + parts[1]);\n                mappings[key] = key2;\n            }\n            else nodes.push({\n                key: key,\n                value: inode.value()\n            });\n        });\n        pattern.edges().forEach(function(iedge) {\n            var val2 = Object.assign({}, iedge.value());\n            val2.source = lookup(patnode.key() + '.' + iedge.source().key());\n            val2.target = lookup(patnode.key() + '.' + iedge.target().key());\n            edges.push({\n                key: patnode.key() + '.' + iedge.key(),\n                value: val2\n            });\n        });\n    });\n    return mg.pattern({\n        interface: {\n            nodes,\n            edges\n        }\n    }, flowspecs);\n};\n"]}